学习笔记
本周主要学习了哈希表、树，堆这些数据结构；

一、哈希表
    正常情况的插入删除查询的时间复杂度都可以达到O(1)，最坏的情况是O(n)，n是哈希表访问的位置存储的链表元素个数;
哈希表，也叫散列表，根据关键码值直接进行访问的数据结构，通过关键码值映射到表中的一个位置来访问记录，以加快查找速度；
这个映射函数叫做散列函数（哈希函数），存放记录的数据叫做哈希表；
    为了尽可能使存储的元素散列的存放在哈希表中，需要哈希函数尽量减少碰撞，
例如java中的hashMap的哈希函数使用key的hashCode()高16位异或低16位再取模，降低哈希冲突，减少碰撞几率；

二、树
   树的结构中主要常用的有二叉树，二叉搜索树，树的结构来源于生活思考，许多事物都可以用树形结构表达；
   二叉树的遍历：
        前序（Pre-order）：根-左-右
        中序（In-order）：左-根-右
        后序（Post-order）：左-右-根
   二叉搜索树（Binary Search Tree）
        也叫二叉排序树、有序二叉树，排序二叉树，具有下列性质：
        1、左子树的所有结点的值均小于它根节点的值；
        2、右子树的所有结点的值均大于它根节点的值；
        3、以此类推：左右子树也分别是二叉查找树（重复性）。
        中序遍历就是升序遍历，查询插入时间复杂度都是O(log2N);
        
三、堆
    Heap：可以迅速的找到一堆数中的最大值或者最小值；
    将根节点最大的叫做大顶堆或大根堆，根节点最小的叫做小顶堆或小根堆，常见有二叉堆、斐波那契堆等；
    find-max:O(1)
    delete-max:O(logN)
    insert(create):O(logN) or O(1)
  二叉堆：通过完全二叉树实现，常见简单；
    （大顶堆）满足两个性质：一、是一颗完全树；二、树中任意节点的值总是>=其子节点的值
    实现细节：1、一般通过数组实现；
            2、假设"第一个元素"在数组中索引为0；
            则父节点和子节点位置关系如下：
            （1）索引i的左孩子索引为（2*i+1）；
            （2）索引i的右孩子索引为（2*i+2）；
            （3）索引为i的父节点索引为floor((i-1)/2)；
            insert，插入尾部，然后向上调整，直到不在大于父亲节点；
            delete，堆尾元素替换到顶部，然后向下调整直到堆尾；
    
心得体会
    本周学习的数据结构由一维转向多维，就像第一周的说的，多维的数据结构变增删查各方面性能都有多提升，数据结构定义会更复杂一点；
面对不同的场景和问题，可以针对性的选择；
    比如经常查找数据中的最大值或者最小值，就是可以是用堆的数据结构；

HashMap总结
    首先HashMap基于哈希表的设计，底层是数组，称为哈希桶，通过关键码key的哈希函数进行访问，
    如果产生哈希碰撞则桶中元素使用链表形式存储，jdk1.8后，链表个数大于8的时候会转化成红黑树，小于6的时候又转回链表；
    增删改正常情况的时间复杂度都是O(1),最糟糕的会变成O(N);
    
    
    
    
